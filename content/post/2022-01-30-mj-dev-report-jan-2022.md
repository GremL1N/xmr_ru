---
title: "Отчёт mj за январь по разработке и интеграциям"
date: "2022-01-30"
categories:
  - "Новости"
tags:
  - "CCS"
lead: "Ежемесячный отчёт mj в ключе работы над его CCS предложением."
pager: true
toc: false
sidebar: "right"
widgets:
  - "recent"
  - "taglist"
---

Уважаемое сообщество!

В течение последних трёх месяцев более чем 90% моей работы были посвящены минимальной, но в то же самое время очень практичной версии симулятора [tsqsim](https://github.com/mj-xmr/tsqsim), который поможет разработчикам Monero в построении моделей прогнозирования. Модель, над которой я работаю в настоящее время, позволяет спрогнозировать сумму транзакции Monero в следующем временном интервале для [OSPEAD](https://ccs.getmonero.org/proposals/Rucknium-OSPEAD-Fortifying-Monero-Against-Statistical-Attack.html). Однако во время проведения последних встреч Исследовательской лаборатории Monero, как и предполагалось, нашлось больше способов применения (как, например, во время [этой встречи](https://github.com/monero-project/meta/issues/651)). Учитывая весь потенциал применения симулятора в будущем, считаю своим долгом надлежащим образом задокументировать инструмент и сделать его достаточно простым в обращении, чтобы изначально не демотивировать разработчиков. С технической стороны мною была подготовлена система, которая на данный момент принимает различные форматы вводных данных и которая даже способна автоматически предположить, какие вводные данные получит. В то же самое время я буду доступен, если кому-либо из исследователей Monero понадобится техническая поддержка при работе с инструментом. Фактически несколько дней назад, после того как я показал [u/Rucknium](https://www.reddit.com/u/Rucknium/) последние графики (ACF, PACF & co.), сгенерированные (не напрямую) с помощью инструмента и соответствующие промышленным стандартам анализа статистических данных, я сразу же почувствовал, что мы начинаем говорить на одном языке. Необходимо понять, что до этого момента я был полностью поглощён попытками создать что-то полезное к обозначенному сроку, а в самом инструменте есть множество технических нюансов, так что найти общий язык с кем-то ещё в конечном итоге — уже большой успех. Это означает, что мы можем сфокусироваться на работе над деталями / внутренним устройством, никак не обременяя друг друга, а в конце мы точно так же сможем проводить встречи и говорить на языке, который будет понятен абсолютно всем. Скажем так в последствии мы будем знать, как отразятся результаты этих встреч на наших индивидуальных мирах.

Чтобы добавить некоторый контекст описанному разговору, приведу один из представленных мной новых графиков, посвящённых «сезонному распределению» ([Seasonal Decomposition](https://en.wikipedia.org/wiki/Decomposition_of_time_series)):

![01](/img/post/2022-01-30-mj-dev-report-jan-2022/01.png)
*Сезонное распределение транзакций Monero (ежедневные данные в течение недели)*

Сверху представлены следующие подграфики:
- Наблюдаемые последовательности (количество транзакций)
- Сезонный компонент 1) для каждого повторяющегося дня недели
- Составляющая тренда 1)
- Остаток

Rucknium сразу же связал вышеуказанный график (в частности, 2 подграфика сверху) с подробной [публикацией](https://mitchellpkt.medium.com/fingerprinting-a-flood-forensic-statistical-analysis-of-the-mid-2021-monero-transaction-volume-a19cbf41ce60), написанной ранее [u/isthmus](https://www.reddit.com/u/isthmus/), где им были выявлены подобные устойчивые сезонные шаблоны (не забывайте, что мои являются обратными из-за небольшого бага):

![02](/img/post/2022-01-30-mj-dev-report-jan-2022/02.png)
*Те же сезонные шаблоны, выявленные isthmus*

Дополнительными стандартными графиками, которые должен иметь под рукой каждый занимающийся анализом временных рядов, являются ACF и PACF:

![03](/img/post/2022-01-30-mj-dev-report-jan-2022/03.png)
*График автокорреляции (ACF)*

![04](/img/post/2022-01-30-mj-dev-report-jan-2022/04.png)
*График частичной автокорреляции (PACF)*

Для понимания логики, лежащей в основе построения графиков ACF и PACF, я рекомендую посмотреть этот [клип](https://www.youtube.com/watch?v=DeORzP0go5I&list=PLvcbYUQ5t0UHOLnBzl46_Q6QKtFgfMGc3&index=2). Пояснения того же автора, связанные с сезонностью, можно найти [здесь](https://www.youtube.com/watch?v=4hrMdu9CSQs&list=PLvcbYUQ5t0UHOLnBzl46_Q6QKtFgfMGc3&index=21).

В случае Monero отрицательная автокорреляция на ранних интервалах означает, что в течение большей части времени **изменение** количества транзакций чередуется между высокими интервалами (на 1, 2 шаге) и значительно более низким в последующем интервале и наоборот.

По большей части на этом и заканчивается общение на человеческом языке в течение последних 3 месяцев. И перед тем, как перейду к техническим подробностям основных преимуществ tsqsim, мне бы хотелось коротко упомянуть об остальной работе, проделанной мной непосредственно для Monero (то есть об оставшихся 10%).

### _Прямой вклад в проект Monero_

В последнее время было открыто относительно немного пул-реквестов, и я помог разобраться с теми из них, где мог принести реальную пользу (связанными с IT). Также я заглянул в проект Monero-GUI и закрыл своими ответами несколько соответствующих моей специализации пул-реквестов. Большинство из них вскоре были включены в репозиторий, и я перезапустил мой статистический инструмент Monero, сохраняющий результаты по обычному адресу:

http://cryptog.hopto.org/monero/health/

За последние 3 месяца мне приходилось запускать инструмент трижды.

Вместе с [u/selsta](https://www.reddit.com/u/selsta/), действовавшего в качестве редактора, я позаботился о процессе перехода с Mac OSX 10 на Mac OSX 11 в рамках непрерывной интеграции GitHub, чтобы всё гарантированно работало к моменту окончательного перехода, который состоится 13 декабря, и чтобы мы неожиданно не упёрлись лбом в стену в результате появления каких-либо неожиданных ошибок.

Подобным образом я позаботился и о переходе с Windows 2019 на Windows 2022, о чём было упомянуто на GitHub [здесь](https://github.com/actions/virtual-environments/issues/4856). В данном случае мною был смоделирован переход не только для основной [Core-версии](https://github.com/mj-xmr/monero-mj/actions/runs/1765302801), но и для [GUI](https://github.com/mj-xmr/monero-gui-mj/actions/runs/1765318799). К счастью, как смоделированный, так фактический процесс перехода были реализованы совершенно без ошибок. Это во многом связано с достигнутой относительной стабильностью кодовой базы в отношении включения заголовков, связывания библиотек и использования стандартизованных функций C++. Отказы по одному из этих трёх фронтов являются типичной причиной ошибок при подобных переходах.

### _Новости tsqsim_

А теперь я бы хотел немного подробнее написать о tsqsim, самой приоритетной работе за последние 3 месяца. Я расскажу об основных достижениях не в хронологическом порядке, а начиная с самых важных. Степень важности в данном случае измеряется тем, насколько инструмент может использоваться исследователями Monero (особенно Rucknium) на данный момент.

### _Интеграция с R_

Интеграция с [проектом R](https://www.r-project.org/) всегда была заявленным требованием со стороны Rucknium. Мне удалось соединить моё приложение с внешним скриптом R, чтобы любой мог произвести модификацию, не прибегая к следующему:
- раскрытию полученных результатов до тех пор, пока выявленные уязвимости не будут устранены;
- рекомпиляции симулятора;
- использованию подключаемого интерфейса, что создаёт некоторые технические проблемы, по крайней мере, на данном этапе.

Часть интеграции на C++ можно посмотреть [здесь](https://github.com/mj-xmr/tsqsim/blob/master/src/lib-base/src/PredictorRCustom.cpp), а пример рабочего скрипта, готового для расширения в любой момент, хранится [здесь](https://github.com/mj-xmr/tsqsim/blob/master/src/tsqsim-lib/static/scripts/r-custom.R).

### _wxConfigurator_

Помимо пока ещё не законченного интерфейса командной строки, есть ещё один важный инструмент GUI, контролирующий поведение симулятора и делающий, в том числе благодаря всплывающим описаниям, его функции прозрачными — это конфигуратор на базе wxWidget.

![05](/img/post/2022-01-30-mj-dev-report-jan-2022/05.png)
*wxConfigurator*

### _Непрерывная интеграция (CI)_

В первой половине декабря я потратил порядочно времени, чтобы убедиться в том, что проект работает на всех платформах, поддерживаемых GitHub Actions (Ubuntu Linux, Mac OSX и Windows), особенно Mac OSX, поскольку именно на этой платформе Rucknium проводит свои исследования. Он подтвердил, что ему удалось запустить wxConfigurator и симулятор консоли под его версией Mac OSX.

Ниже приводится последнее (на момент написания этого отчёта) [состояние CI](https://github.com/mj-xmr/tsqsim/actions/runs/1765909715), показаны все платформы и комбинации параметров (если они имеют значение) с учётом отношения выгоды/затрат.

![06](/img/post/2022-01-30-mj-dev-report-jan-2022/06.png)
*CI симулятора tsqsim на GitHub с различными платформами и комбинациями настроек*

Обратите внимание на наличие опции --lto (сокр. от Link Time Optimization), которая крайне важна в случае с подобным ресурсоёмким моделированием, поскольку в сочетании со статическим связыванием она обеспечивает примерно 40% ускорение на этапе циклических вычислений или, проще говоря, на "этапе изготовления продукта".

### _Альтернатива Python для Qt App_

Благодаря CI мне удалось обнаружить, что библиотека Qt, которой я пользуюсь для составления графиков, к сожалению, устарела настолько, что позволяет компилировать только под Ubuntu 20.04 и соответствующей базе Debian, Debian Buster (ранее Debian-stable). Портирование Qt App стало бы ещё одной серьёзной и важной задачей, на решение которой понадобился целый месяц, особенно учитывая те уникальные интерактивные функции, которые она обеспечивает. И всё же, чтобы симулятор можно было визуализировать на самых последних платформах, для которых используемая на данный момент версия библиотека Qt является уже устаревшей, мне пришлось найти подходящую альтернативу, которой стала портативная библиотека Matplotlib Python. Ниже мною приводится доказательство того, что визуализация Qt App (верхнее окно) может быть воспроизведена с помощью менее интерактивной, но визуально эквивалентной альтернативы на базе Python (нижнее окно):

![07](/img/post/2022-01-30-mj-dev-report-jan-2022/07.png)
*Интерактивная визуализация Qt App (сверху) и её эквивалент на базе Python (снизу)*

### _Оптимизация_

Как и было обещано, мною были интегрированы методы оптимизации, которые я уже использовал в других проектах, где требовалась оптимизация (а это значит, что соответствующие методы уже прошли нагрузочные испытания в этой сфере). При оптимизации происходит попытка найти такие комбинации параметров модели (прогнозирования), которые доводят до максимума функцию выгоды (или доводят до минимума функцию затрат), при этом функция выгоды представляет собой относительную эффективность прогнозирования вашей модели (зелёный график) относительно базового прогноза (серый график). Базовый прогноз — это просто копия точки данных предыдущего сигнала, поэтому вы наблюдаете проекцию сигнала (синий график).

Решение может быть оптимизировано тремя методами: простым поиском по сетке [O(n^m)], многомерным делением пополам [O(m*log(n))] и методом Монте-Карло [O(n)]. Последний из них имеет опцию ранней остановки, которая позволяет прекратить дальнейшие вычисления, когда изменения дисперсии падают ниже определенного настраиваемого порогового значения, или, другими словами, всякий раз, когда можно наблюдать, что решение более не улучшается в течение десятка последних итераций. Например, в случае с показанным ниже поиском оптимальных параметров, если будет выбрана соответствующая опция, процесс будет остановлен примерно на итерации №99:

![08](/img/post/2022-01-30-mj-dev-report-jan-2022/08.png)
*Изменения дисперсии в решениях, выявленные с помощью метода Монте-Карло. Y = изменения дисперсии, X = итерация*

Оптимизация методом Монте-Карло является особым случаем, поскольку предлагает целый набор результатов, а не один отдельно взятый результат, что позволяет нам краешком глаза заглянуть в будущее и увидеть, как модель поведёт себя с новыми данными: чем больше количество различных наборов параметров, которые будут лучше базового, тем выше вероятность, что в будущем модель будет лучше работать на будущем на основе параметров, полученных в результате обучения с использованием доступных на текущий момент данных. Это можно обосновать следующим образом: если гиперплоскость оптимальных решений будет достаточно широкой, всегда можно будет найти «достаточно хорошее» решение, даже если шаблоны новых данных немного изменятся. Безусловно, «достаточно хорошее» всегда будет означать «лучше, чем базовый прогноз». Распределение решений, представленное в виде графика в консольном окне вместе с текстовым представлением под графиком:

![09](/img/post/2022-01-30-mj-dev-report-jan-2022/09.png)
*Распределение решений, найденное с помощью метода Монте-Карло. Y = наличие, X = оценка пригодности*

Важно уточнить одну деталь: у метода поиска по сетке есть недостаток, называемый «[проклятием размерности](https://en.wikipedia.org/wiki/Curse_of_dimensionality)» или «[комбинаторным взрывом](https://en.wikipedia.org/wiki/Combinatorial_explosion)». Это означает, что по мере роста количества параметров (размерности) время их обработки (то есть оптимизации)растёт по экспоненте (только вдумайтесь, это может занять дни или даже недели). Ни в случае с методом многомерного деления пополам, ни в случае с методом Монте-Карло подобной проблемы не возникает благодаря их сложности. По опыту знаю, что они могут быть прекрасным дополнением.

### _Продвижение в направлении валидации_

Даже новички в области машинного обучения знают о методе стандартной валидации оценки прогнозирования под названием [кросс-валидация](https://en.wikipedia.org/wiki/Cross-validation_(statistics)) (CV). При проведении анализа временных рядов мы не можем позволить себе такую роскошь, как перетасовка данных, которую использует оригинальный метод CV, поскольку текущая и следующая (прогнозируемая) точка данных зависит от предыдущих точек данных и не может быть никак связана с [будущими точками данных](https://www.investopedia.com/terms/l/lookaheadbias.asp), так как это может привести к появлению систематической ошибке опережения. Другими словами, путём самообмана и обмана ваших клиентов (как и в реальности) вы никогда не достигните производительности, которую демонстрирует вам ваша система, если будете жульничать подобным образом (даже если факт жульничества будет абсолютно неумышленным).

Таким образом, в TSA всё, что у нас остаётся — окно валидации, которое движется только вперёд по времени и называется [walk-forward валидацией](https://en.wikipedia.org/wiki/Walk_forward_optimization) (или оптимизацией).Таким образом, в TSA всё, что у нас остаётся — окно валидации, которое движется только вперёд по времени и называется walk-forward валидацией (или оптимизацией). Проект уже позволяет применять этот метод валидации, но вместе с тем стоит признать, что есть некоторые функции, связанные с UI, которые требуют примерно неделю работы. Хорошая новость состоит в том, что данные сумм транзакций Monero достаточно хорошо прогнозируются, поэтому даже мой собственный первоначальный вариант прогностической модели, который позволил добиться на 20-30% лучших показателей, чем базовая модель, не будет страдать от заметных регрессий показателей, по крайней мере, в течение последующих 2 месяцев без переобучения (за пределами выборки). Это означает, что, если даже модель придётся подгонять вручную (то есть до того, как она будет автоматизирована), это будет делаться не чаще одного раза в месяц. См. ниже:

![10](/img/post/2022-01-30-mj-dev-report-jan-2022/10.png)
*Необученная модель*

![11](/img/post/2022-01-30-mj-dev-report-jan-2022/11.png)
*Обученная модель и показатели её работы в пределах выборки*

![12](/img/post/2022-01-30-mj-dev-report-jan-2022/12.png)
*Та же модель с теми же параметрами, которые были изучены ранее, но демонстрирующая оценку вне выборки на данных, полученных месяц спустя*

Относительная производительность, по сравнению с базовым уровнем, при тестировании в выборке снизилась со 100–75% = 25% до 100–77% = 23% в случае с решающим тестированием вне выборки в следующем месяце, то есть всего на 2%.

Вместе с тем по-прежнему остаётся ряд проблем, требующих решения. Я отслеживаю их на [Wiki проекта](https://github.com/mj-xmr/tsqsim/wiki). Как видите, есть ещё много, о чём рассказать, но мне не хотелось бы утомлять вас теми вещами, которые пока не сделаны и о которых я пока не рассказываю, тем более что пост и так получился довольно длинным.

Однако точно необходимо упомянуть, что моя подруга Hajer решила, что не справится со специально подобранными для неё побочными заданиями, пожаловавшись на отсутствие у неё необходимого для этого опыта. Одна из поставленных перед ней задач состояла в написании альтернативы построению графиков Qt: Python, что я уже сделал сам, как только услышал эти плохие новости. Второй проблемой стало портирование приложения Qt на последние версии основных операционных систем, что я обещаю сделать в следующей итерации моего предложения, которое скоро будет мною опубликовано. Если честно, я не верю, что она не справилась бы с задачами, но я полостью понимаю её чувства и осознаю, что она осталась абсолютно без душевных сил после того, как ваш сотрудник ментально насиловал её по 8 с лишним часов ежедневно. Другими словами, чем больше я вникаю в её ситуацию, тем больше ценю имеющуюся у меня возможность заниматься разработкой симулятора и принять участие в исследовании и  разработке Monero в целом за приличную плату вместо того, чтобы разделить злосчастную судьбу других сотрудников. Спасибо вам всем, ребята, и будем надеяться, что однажды Hajer расправит свои
обломанные крылья и устремится в нашем направлении :)

mj

---

_Источник: [mj's dev report: Jan. 2021](https://www.reddit.com/r/Monero/comments/sfs195/mjs_dev_report_2022_jan/)_

_Перевод: [Mr. Pickles](https://t.me/v1docq47)_  
_Коррекция: [Kukima](https://t.me/Kukima)_
